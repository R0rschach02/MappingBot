#include <ESP32Servo.h>

Servo servoY;
Servo servoX;

const int servoPinY = 19;
const int servoPinX = 26;

void setup() 
{
  
  Serial.begin(115200);
  
  ESP32PWM::allocateTimer(0);
  ESP32PWM::allocateTimer(1);
  ESP32PWM::allocateTimer(2);
  ESP32PWM::allocateTimer(3);
  
  servoX.setPeriodHertz(50);
  servoX.attach(servoPinX, 1500, 2500);

  //servoX.write(115);
  servoX.write(90);

  servoY.setPeriodHertz(50);
  servoY.attach(servoPinY, 1500, 2500);

  servoY.write(150); // 90° ist der Mittelpunkt vom Y servo, 115 ist der max wert. 

  delay(2000);
}

void radarFSM_Advanced()
{
  static unsigned long timeShot = 0;
  unsigned long timeNow = millis();

  static boolean backwardX= true; 
  static boolean backwardY= true; 
  
  static byte posX = 90; // zuvor 115°
  static byte posY = 90;

  // die x achse fängt bei der Koordinate 115° an und bewegt sich bis zu 30° 
  // die y achse bleibt fürs erste zentriert beim Wert 105 °. 
  // Der y wert soll anfangs runtergezählt werden bis x den wert 80 erreicht hat, danach soll wieder y hochgezählt werden bis x wieder bei 115° ist.
  // Ist der X wert bei 115° angekommen wird y wieder runtergezählt bis x die koordinate 80° erreicht hat. 

    if(timeNow - timeShot >= 29)
  {
    timeShot = timeNow;
    
    if( posX > 30 && backwardX == true )   // posX > 30 && backwardX == true
    {
      posX--;
      
      if ( posX <= 30 )
      {
        backwardX = false; 
      }
    }

    
    else if ( backwardX == false  )
    {
      posX++;  
      
      if( posX == 125)
      {
        backwardX = true; 
      }
    }

      // x achse wird sich dauernd von 30° bis 115° bewegen. Jetzt kommt die Y achse: 
  // Der y wert soll anfangs runtergezählt werden bis x den wert 80 erreicht hat, danach soll wieder y hochgezählt werden bis x wieder bei 30° ist.
  // Ist der X wert bei 115° angekommen wird y wieder runtergezählt bis x die koordinate 80° erreicht hat.

  
      if( ( posX <= 125 && posX >= 81) && backwardY == true )   // adder >= 0 && adder <= 179
    {
      posY-=1;
      
      if ( posX == 80 && posY == 65 )
      {
        backwardY = false; 
      }
    }

      else if ( ( posX >= 30 && posX == 80 ) &&  backwardY == false )
    {
      posY+=1;  
      
      if( posX == 125 && posY <= 90 )
      {
        backwardY = true; 
      }
    }
  

  Serial.printf(" X Achse: %u und Y Achse: %u \n" , posX, posY);
  servoX.write(posX);
  servoY.write(posY);
  }

  
  
}

void radarFSM()
{
  static unsigned long timeShot = 0;
  unsigned long timeNow = millis();

  static boolean forwardX= true; 
  static boolean forwardY= true; 
  
  static int posX = 30;
  static int posY = 90;
  
  if(timeNow - timeShot >= 25)
  {
    timeShot = timeNow;
    
    if( posX <  140 && forwardX == true )   // adder >= 0 && adder <= 179
    {
      posX++;
      
      if ( posX >= 140 )
      {
        forwardX = false; 
      }
    }

    
    else if ( forwardX == false  )
    {
      posX--;  
      
      if( posX == 30)
      {
        forwardX = true; 
      }
    }

// Für bewegung entlang der Y Achse: 

    if( posY < 115 && forwardY == true )   // adder >= 0 && adder <= 179
    {
      posY++;
      
      if ( posY >= 90 )
      {
        forwardY = false; 
      }
    }

    
    else if ( forwardY == false  )
    {
      posY--;  
      
      if( posY == 30)
      {
        forwardY = true; 
      }
    }
    

  }


  
  Serial.printf(" X Achse: %u und Y Achse: %u \n" , posX, posY);
  servoX.write(posX);
  servoY.write(posY);
}

void radarFSM2()
{
  static unsigned long timeShot = 0;
  unsigned long timeNow = millis();

  static boolean backwardX= true; 
  static boolean backwardY= true; 
  
  static byte posX = 90; // zuvor 115°
  static byte posY = 150;
  

  // die x achse fängt bei der Koordinate 115° an und bewegt sich bis zu 30° 
  // die y achse bleibt fürs erste zentriert beim Wert 105 °. 
  // Der y wert soll anfangs runtergezählt werden bis x den wert 80 erreicht hat, danach soll wieder y hochgezählt werden bis x wieder bei 115° ist.
  // Ist der X wert bei 115° angekommen wird y wieder runtergezählt bis x die koordinate 80° erreicht hat. 

    if(timeNow - timeShot >= 29)
  {
    timeShot = timeNow;
    
    if( posX >= 30 && backwardX == true )   // posX > 30 && backwardX == true
    {
      posX-=3;  // posX--;
      
      if ( posX <= 30 )
      {
        backwardX = false; 
      }
    }

    
    else if ( backwardX == false  )
    {
      posX+=3; // posX++;  
      
      if( posX == 132) // posX == 126
      {
        backwardX = true; 
      }
    }

      // x achse wird sich dauernd von 30° bis 115° bewegen. Jetzt kommt die Y achse: 
  // Der y wert soll anfangs runtergezählt werden bis x den wert 80 erreicht hat, danach soll wieder y hochgezählt werden bis x wieder bei 30° ist.
  // Ist der X wert bei 115° angekommen wird y wieder runtergezählt bis x die koordinate 80° erreicht hat.

  
      if(  posX == 30 && backwardY == true )   // adder >= 0 && adder <= 179
    {
      posY-=10;
      
      if ( posY == 40 ) // posY == 45
      {
        backwardY = false; 
      }
    }

      else if ( posX == 132 &&  backwardY == false ) // ( posX == 126 &&  backwardY == false )
    {
      posY+=10;  
      
      if( posY == 150 ) // posX == 125 && posY >= 125 und davor auf 120
      {
        backwardY = true; 
      }
    }
  

  Serial.printf(" X Achse: %u und Y Achse: %u \n" , posX, posY);
  servoX.write(posX);
  servoY.write(posY);
  }
}


void loop() 
{
  //radarFSM(); 
  //radarFSM_Advanced();
  radarFSM2();
}
